---
alwaysApply: false
globs:
  - "**/*.tsx"
---

Red flags in a React codebase

ðŸš© functions like <button onClick={handleClick}

- handleClick doesn't explain what it does
- you lose colocation
- need new names for each callback

Inline callbacks can call multiple functions with good names

onClick={() => {
analytics.event('this-button')
openModal()

ðŸš© useMemo

React devs are terrified of renders and often overuseMemo

- memoize things that you pass as props to components that may have expensive children
- it's ok for leaf components to over-render

useMemo does not fix bugs, it just makes them happen less often

ðŸš© <div onClick

divs are not interactive elements and adding onClick requires implementing keyboard control, screen reader announcement, etc

This is almost never the right move, and anyone capable of doing it right (the new tweet button) isn't going to be swayed by this tweet

ðŸš© useEffect to sync state

Using useEffect to sync state from props or other state is a code smell. Prefer derived state instead.

âŒ Bad - useEffect to sync state:
```tsx
const [selectedItem, setSelectedItem] = useState(null);

useEffect(() => {
  if (data?.defaultItem && !selectedItem) {
    setSelectedItem(data.defaultItem);
  }
}, [data?.defaultItem, selectedItem]);
```

âœ… Good - Derived state:
```tsx
const [userSelectedItem, setUserSelectedItem] = useState(null);
const selectedItem = userSelectedItem ?? data?.defaultItem ?? null;
```

Benefits of derived state:
- No extra render from the useEffect setState
- Clearer data flow - easy to see where the value comes from
- No stale closure bugs
- Works correctly on first render (useEffect runs after render)
