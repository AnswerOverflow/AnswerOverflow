#!/usr/bin/env bun

/**
 * Codegen script to extract function types from Convex API
 *
 * This script analyzes the private and public modules to determine which functions
 * are queries, mutations, or actions, and generates a runtime mapping.
 */

import { readdir, readFile } from "node:fs/promises";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const PACKAGE_ROOT = join(__dirname, "..");
const PRIVATE_DIR = join(PACKAGE_ROOT, "convex/private");
const PUBLIC_DIR = join(PACKAGE_ROOT, "convex/public");
const OUTPUT_FILE = join(PACKAGE_ROOT, "src/generated/function-types.ts");

interface FunctionInfo {
	path: string;
	type: "query" | "mutation" | "action";
}

async function extractFunctionsFromFile(
	filePath: string,
	namespace: string,
	isPublic: boolean,
): Promise<FunctionInfo[]> {
	const content = await readFile(filePath, "utf-8");
	const functions: FunctionInfo[] = [];

	const queryPattern = isPublic ? "publicQuery" : "privateQuery";
	const mutationPattern = isPublic ? "publicMutation" : "privateMutation";
	const actionPattern = isPublic ? "publicAction" : "privateAction";

	const queryRegex = new RegExp(
		`export\\s+(?:const|function)\\s+(\\w+)\\s*=\\s*${queryPattern}`,
	);
	const mutationRegex = new RegExp(
		`export\\s+(?:const|function)\\s+(\\w+)\\s*=\\s*${mutationPattern}`,
	);
	const actionRegex = new RegExp(
		`export\\s+(?:const|function)\\s+(\\w+)\\s*=\\s*${actionPattern}`,
	);

	const queryMatches = [
		...content.matchAll(new RegExp(queryRegex.source, "g")),
	];
	const mutationMatches = [
		...content.matchAll(new RegExp(mutationRegex.source, "g")),
	];
	const actionMatches = [
		...content.matchAll(new RegExp(actionRegex.source, "g")),
	];

	for (const match of queryMatches) {
		const funcName = match[1];
		functions.push({
			path: namespace ? `${namespace}.${funcName}` : funcName,
			type: "query",
		});
	}

	for (const match of mutationMatches) {
		const funcName = match[1];
		functions.push({
			path: namespace ? `${namespace}.${funcName}` : funcName,
			type: "mutation",
		});
	}

	for (const match of actionMatches) {
		const funcName = match[1];
		functions.push({
			path: namespace ? `${namespace}.${funcName}` : funcName,
			type: "action",
		});
	}

	return functions;
}

async function scanDirectory(
	dir: string,
	isPublic: boolean,
	allFunctions: FunctionInfo[],
	namespaces: Set<string>,
	namespaceToFunctions: Map<string, FunctionInfo[]>,
): Promise<void> {
	const files = await readdir(dir);

	for (const file of files) {
		if (file.endsWith(".test.ts") || !file.endsWith(".ts")) {
			continue;
		}
		if (file === "custom_functions.ts") {
			continue;
		}

		const filePath = join(dir, file);
		const namespace = file.replace(".ts", "");
		namespaces.add(namespace);

		const functions = await extractFunctionsFromFile(
			filePath,
			namespace,
			isPublic,
		);
		allFunctions.push(...functions);

		const existing = namespaceToFunctions.get(namespace) || [];
		namespaceToFunctions.set(namespace, [...existing, ...functions]);
	}
}

async function generateFunctionTypes(): Promise<void> {
	const allFunctions: FunctionInfo[] = [];
	const namespaces = new Set<string>();
	const namespaceToFunctions = new Map<string, FunctionInfo[]>();

	await scanDirectory(
		PRIVATE_DIR,
		false,
		allFunctions,
		namespaces,
		namespaceToFunctions,
	);
	await scanDirectory(
		PUBLIC_DIR,
		true,
		allFunctions,
		namespaces,
		namespaceToFunctions,
	);

	allFunctions.sort((a, b) => a.path.localeCompare(b.path));

	const uniqueFunctions = new Map<string, FunctionInfo>();
	for (const func of allFunctions) {
		if (!uniqueFunctions.has(func.path)) {
			uniqueFunctions.set(func.path, func);
		}
	}

	const typeMapEntries = Array.from(uniqueFunctions.values())
		.map((f) => `  "${f.path}": "${f.type}"`)
		.join(",\n");

	const namespaceArray = Array.from(namespaces).sort();

	const namespaceStructureEntries = namespaceArray
		.map((ns) => {
			const functions = namespaceToFunctions.get(ns) || [];
			const functionNames = [
				...new Set(functions.map((f) => f.path.split(".")[1])),
			].sort();
			return `  "${ns}": ${JSON.stringify(functionNames)}`;
		})
		.join(",\n");

	const output = `// Auto-generated by scripts/generate-function-types.ts
// DO NOT EDIT MANUALLY

export const FUNCTION_TYPE_MAP = {
${typeMapEntries}
} as const;

export const NAMESPACES = ${JSON.stringify(namespaceArray)} as const;

export const NAMESPACE_STRUCTURE = {
${namespaceStructureEntries}
} as const;

export type FunctionPath = keyof typeof FUNCTION_TYPE_MAP;
export type FunctionType = typeof FUNCTION_TYPE_MAP[FunctionPath];

export function getFunctionType(path: FunctionPath): FunctionType {
	return FUNCTION_TYPE_MAP[path];
}

export function isNamespace(key: string): key is keyof typeof NAMESPACE_STRUCTURE {
	return key in NAMESPACE_STRUCTURE;
}

export function getNamespaceFunctions(namespace: keyof typeof NAMESPACE_STRUCTURE): readonly string[] {
	return NAMESPACE_STRUCTURE[namespace];
}
`;

	await Bun.write(OUTPUT_FILE, output);
	console.log(
		`Generated ${allFunctions.length} function mappings and ${namespaces.size} namespaces in ${OUTPUT_FILE}`,
	);
}

generateFunctionTypes().catch((error) => {
	console.error("Error generating function types:", error);
	process.exit(1);
});
