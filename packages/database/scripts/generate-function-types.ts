#!/usr/bin/env bun

/**
 * Codegen script to extract function types from Convex API
 *
 * This script analyzes the private modules to determine which functions
 * are queries, mutations, or actions, and generates a runtime mapping.
 */

import { readdir, readFile } from "node:fs/promises";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const PACKAGE_ROOT = join(__dirname, "..");
const PRIVATE_DIR = join(PACKAGE_ROOT, "convex/private");
const OUTPUT_FILE = join(PACKAGE_ROOT, "src/generated/function-types.ts");

interface FunctionInfo {
	path: string;
	type: "query" | "mutation" | "action";
}

async function extractFunctionsFromFile(
	filePath: string,
	namespace: string,
): Promise<FunctionInfo[]> {
	const content = await readFile(filePath, "utf-8");
	const functions: FunctionInfo[] = [];

	// Match exported functions that use privateQuery, privateMutation, or privateAction
	const queryRegex = /export\s+(?:const|function)\s+(\w+)\s*=\s*privateQuery/;
	const mutationRegex =
		/export\s+(?:const|function)\s+(\w+)\s*=\s*privateMutation/;
	const actionRegex = /export\s+(?:const|function)\s+(\w+)\s*=\s*privateAction/;

	// Find all matches
	const queryMatches = [
		...content.matchAll(new RegExp(queryRegex.source, "g")),
	];
	const mutationMatches = [
		...content.matchAll(new RegExp(mutationRegex.source, "g")),
	];
	const actionMatches = [
		...content.matchAll(new RegExp(actionRegex.source, "g")),
	];

	for (const match of queryMatches) {
		const funcName = match[1];
		functions.push({
			path: namespace ? `${namespace}.${funcName}` : funcName,
			type: "query",
		});
	}

	for (const match of mutationMatches) {
		const funcName = match[1];
		functions.push({
			path: namespace ? `${namespace}.${funcName}` : funcName,
			type: "mutation",
		});
	}

	for (const match of actionMatches) {
		const funcName = match[1];
		functions.push({
			path: namespace ? `${namespace}.${funcName}` : funcName,
			type: "action",
		});
	}

	return functions;
}

async function generateFunctionTypes(): Promise<void> {
	const allFunctions: FunctionInfo[] = [];
	const namespaces = new Set<string>();
	const namespaceToFunctions = new Map<string, FunctionInfo[]>();

	// Read all files in private directory
	const files = await readdir(PRIVATE_DIR);

	for (const file of files) {
		// Skip test files and non-TypeScript files
		if (file.endsWith(".test.ts") || !file.endsWith(".ts")) {
			continue;
		}

		const filePath = join(PRIVATE_DIR, file);
		// Extract namespace from filename (e.g., "servers.ts" -> "servers")
		const namespace = file.replace(".ts", "");
		namespaces.add(namespace);

		const functions = await extractFunctionsFromFile(filePath, namespace);
		allFunctions.push(...functions);
		namespaceToFunctions.set(namespace, functions);
	}

	// Sort functions by path for consistent output
	allFunctions.sort((a, b) => a.path.localeCompare(b.path));

	// Generate the output file
	const typeMapEntries = allFunctions
		.map((f) => `  "${f.path}": "${f.type}"`)
		.join(",\n");

	const namespaceArray = Array.from(namespaces).sort();

	// Generate namespace structure map
	const namespaceStructureEntries = namespaceArray
		.map((ns) => {
			const functions = namespaceToFunctions.get(ns) || [];
			const functionNames = functions.map((f) => f.path.split(".")[1]).sort();
			return `  "${ns}": ${JSON.stringify(functionNames)}`;
		})
		.join(",\n");

	const output = `// Auto-generated by scripts/generate-function-types.ts
// DO NOT EDIT MANUALLY

export const FUNCTION_TYPE_MAP = {
${typeMapEntries}
} as const;

export const PRIVATE_NAMESPACES = ${JSON.stringify(namespaceArray)} as const;

export const NAMESPACE_STRUCTURE = {
${namespaceStructureEntries}
} as const;

export type FunctionPath = keyof typeof FUNCTION_TYPE_MAP;
export type FunctionType = typeof FUNCTION_TYPE_MAP[FunctionPath];

export function getFunctionType(path: FunctionPath): FunctionType {
	return FUNCTION_TYPE_MAP[path];
}

export function isNamespace(key: string): key is keyof typeof NAMESPACE_STRUCTURE {
	return key in NAMESPACE_STRUCTURE;
}

export function getNamespaceFunctions(namespace: keyof typeof NAMESPACE_STRUCTURE): readonly string[] {
	return NAMESPACE_STRUCTURE[namespace];
}
`;

	await Bun.write(OUTPUT_FILE, output);
	console.log(
		`Generated ${allFunctions.length} function mappings and ${namespaces.size} namespaces in ${OUTPUT_FILE}`,
	);
}

generateFunctionTypes().catch((error) => {
	console.error("Error generating function types:", error);
	process.exit(1);
});
